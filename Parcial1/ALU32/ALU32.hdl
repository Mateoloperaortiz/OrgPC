CHIP ALU32 {
    IN
        x[32], y[32],
        // Control bits:
        zx, // Zero the x input
        nx, // Negate the x input
        zy, // Zero the y input
        ny, // Negate the y input
        f,  // 1: add, 0: and
        no; // Negate the final output

    OUT
        out[32],
        // Flags
        zr,  // Zero: 1 if out == 0
        ng,  // Negative: 1 if out < 0 (bit 31 is 1)
        ov;  // Overflow: 1 on signed overflow (arithmetic only)

    PARTS:

    ALU(x=x[0..15], y=y[0..15], zx=zx, nx=nx, zy=zy, ny=ny, f=f, no=no,
        out=lowResult, zr=zrLow, ng=ngLow);

    ALU(x=x[16..31], y=y[16..31], zx=zx, nx=nx, zy=zy, ny=ny, f=f, no=no,
        out=highResult, zr=zrHigh, ng=ngHigh);

    And(a=f, b=f, out=isArithmetic);

    Mux16(a=highResult, b=highResult, sel=true, out=finalHigh);

    Not16(in=lowResult, out=lowNot);
    Mux16(a=lowResult, b=lowNot, sel=no, out=out[0..15]);

    Not16(in=finalHigh, out=highNot);
    Mux16(a=finalHigh, b=highNot, sel=no, out=out[16..31]);

    And(a=zrLow, b=zrHigh, out=zr);

    And(a=out[31], b=true, out=ng);

    And(a=false, b=f, out=ov);
}
